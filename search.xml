<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java核心-异常</title>
      <link href="/posts/30b33380/"/>
      <url>/posts/30b33380/</url>
      
        <content type="html"><![CDATA[<h1 id="Java异常"><a href="#Java异常" class="headerlink" title="Java异常"></a>Java异常</h1><h2 id="Java-异常类层次结构图概览："><a href="#Java-异常类层次结构图概览：" class="headerlink" title="Java 异常类层次结构图概览："></a>Java 异常类层次结构图概览：</h2><p><a href="https://imgse.com/i/pkHADhV"><img src="https://s21.ax1x.com/2024/07/23/pkHADhV.png" alt="pkHADhV.png"></a></p><hr><h2 id="Exception-和-Error-有什么区别？"><a href="#Exception-和-Error-有什么区别？" class="headerlink" title="Exception 和 Error 有什么区别？"></a>Exception 和 Error 有什么区别？</h2><p>在 Java 中，所有的异常都有一个共同的祖先 <code>java.lang</code> 包中的 <code>Throwable</code> 类。<code>Throwable</code> 类有两个重要的子类:</p><ul><li><strong><code>Exception</code></strong> :程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。<code>Exception</code> 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。</li><li>**<code>Error</code>**：<code>Error</code> 属于程序无法处理的错误 ，我们没办法通过 <code>catch</code> 来进行捕获不建议通过<code>catch</code>捕获 。例如 Java 虚拟机运行错误（<code>Virtual MachineError</code>）、虚拟机内存不够错误(<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</li></ul><h2 id="Checked-Exception-和-Unchecked-Exception-有什么区别？"><a href="#Checked-Exception-和-Unchecked-Exception-有什么区别？" class="headerlink" title="Checked Exception 和 Unchecked Exception 有什么区别？"></a><a href="https://javaguide.cn/java/basis/java-basic-questions-03.html#checked-exception-%E5%92%8C-unchecked-exception-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">Checked Exception 和 Unchecked Exception 有什么区别？</a></h2><p><strong>Checked Exception</strong> 即 受检查异常 ，Java 代码在编译过程中，如果受检查异常没有被 <code>catch</code>或者<code>throws</code> 关键字处理的话，就没办法通过编译。</p><p>比如下面这段 IO 操作的代码：</p><p><a href="https://imgse.com/i/pkHARB9"><img src="https://s21.ax1x.com/2024/07/23/pkHARB9.png" alt="pkHARB9.png"></a></p><p>除了<code>RuntimeException</code>及其子类以外，其他的<code>Exception</code>类及其子类都属于受检查异常 。常见的受检查异常有：IO 相关的异常、<code>ClassNotFoundException</code>、<code>SQLException</code>…</p><hr><p><strong>Unchecked Exception</strong> 即 <strong>不受检查异常</strong> ，Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。</p><p><code>RuntimeException</code> 及其子类都统称为非受检查异常，常见的有（建议记下来，日常开发中会经常用到）：</p><ul><li><code>NullPointerException</code>(空指针错误)</li><li><code>IllegalArgumentException</code>(参数错误比如方法入参类型错误)</li><li><code>NumberFormatException</code>（字符串转换为数字格式错误，<code>IllegalArgumentException</code>的子类）</li><li><code>ArrayIndexOutOfBoundsException</code>（数组越界错误）</li><li><code>ClassCastException</code>（类型转换错误）</li><li><code>ArithmeticException</code>（算术错误）</li><li><code>SecurityException</code> （安全错误比如权限不够）</li><li><code>UnsupportedOperationException</code>(不支持的操作错误比如重复创建同一用户)</li><li>……</li></ul><p><a href="https://imgse.com/i/pkHA2nJ"><img src="https://s21.ax1x.com/2024/07/23/pkHA2nJ.png" alt="pkHA2nJ.png"></a></p><hr><h2 id="Throwable-类常用方法有哪些？"><a href="#Throwable-类常用方法有哪些？" class="headerlink" title="Throwable 类常用方法有哪些？"></a>Throwable 类常用方法有哪些？</h2><ul><li><code>String getMessage()</code>: 返回异常发生时的简要描述</li><li><code>String toString()</code>: 返回异常发生时的详细信息</li><li><code>String getLocalizedMessage()</code>: 返回异常对象的本地化信息。使用 <code>Throwable</code> 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 <code>getMessage()</code>返回的结果相同</li><li><code>void printStackTrace()</code>: 在控制台上打印 <code>Throwable</code> 对象封装的异常信息</li></ul><h2 id="try-catch-finally-如何使用？"><a href="#try-catch-finally-如何使用？" class="headerlink" title="try-catch-finally 如何使用？"></a>try-catch-finally 如何使用？</h2><ul><li><code>try</code>块：用于捕获异常。其后可接零个或多个 <code>catch</code> 块，如果没有 <code>catch</code> 块，则必须跟一个 <code>finally</code> 块。</li><li><code>catch</code>块：用于处理 try 捕获到的异常。</li><li><code>finally</code> 块：无论是否捕获或处理异常，<code>finally</code> 块里的语句都会被执行。当在 <code>try</code> 块或 <code>catch</code> 块中遇到 <code>return</code> 语句时，<code>finally</code> 语句块将在方法返回之前被执行。</li></ul><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Try to do something&quot;</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;RuntimeException&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Catch Exception -&gt; &quot;</span> + e.getMessage());</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Finally&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Try to do something</span><br><span class="line">Catch Exception -&gt; RuntimeException</span><br><span class="line">Finally</span><br></pre></td></tr></table></figure><p><strong>注意：不要在 finally 语句块中使用 return!</strong> 当 try 语句和 finally 语句中都有 return 语句时，try 语句块中的 return 语句会被忽略。这是因为 try 语句中的 return 返回值会先被暂存在一个本地变量中，当执行到 finally 语句中的 return 之后，这个本地变量的值就变为了 finally 语句中的 return 返回值。</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(f(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value * value;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><hr><h2 id="finally-中的代码一定会执行吗？"><a href="#finally-中的代码一定会执行吗？" class="headerlink" title="finally 中的代码一定会执行吗？"></a>finally 中的代码一定会执行吗？</h2><p>不一定的！在某些情况下，finally 中的代码不会被执行。</p><p>就比如说 finally 之前虚拟机被终止运行的话，finally 中的代码就不会被执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Try to do something&quot;</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;RuntimeException&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Catch Exception -&gt; &quot;</span> + e.getMessage());</span><br><span class="line">    <span class="comment">// 终止当前正在运行的Java虚拟机</span></span><br><span class="line">    System.exit(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Finally&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Try to do something</span><br><span class="line">Catch Exception -&gt; RuntimeException</span><br></pre></td></tr></table></figure><p>另外，在以下 2 种特殊情况下，<code>finally</code> 块的代码也不会被执行：</p><ol><li>程序所在的线程死亡。</li><li>关闭 CPU。</li></ol><hr><h2 id="异常使用有哪些需要注意的地方？"><a href="#异常使用有哪些需要注意的地方？" class="headerlink" title="异常使用有哪些需要注意的地方？"></a>异常使用有哪些需要注意的地方？</h2><ul><li>不要把异常定义为静态变量，因为这样会导致异常栈信息错乱。每次手动抛出异常，我们都需要手动 new 一个异常对象抛出。</li><li>抛出的异常信息一定要有意义。</li><li>建议抛出更加具体的异常比如字符串转换为数字格式错误的时候应该抛出<code>NumberFormatException</code>而不是其父类<code>IllegalArgumentException</code>。</li><li>使用日志打印异常之后就不要再抛出异常了（两者不要同时存在一段代码逻辑中）。</li><li>……</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java核心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java核心-注解</title>
      <link href="/posts/30b33380/"/>
      <url>/posts/30b33380/</url>
      
        <content type="html"><![CDATA[<h1 id="Java注解"><a href="#Java注解" class="headerlink" title="Java注解"></a>Java注解</h1><h2 id="何谓注解"><a href="#何谓注解" class="headerlink" title="何谓注解"></a>何谓注解</h2><p><a href="https://imgse.com/i/pkHABt0"><img src="https://s21.ax1x.com/2024/07/23/pkHABt0.jpg" alt="pkHABt0.jpg"></a></p><p><code>Annotation</code> （注解） 是 Java5 开始引入的新特性，可以看作是一种特殊的注释，主要用于修饰类、方法或者变量，提供某些信息供程序在编译或者运行时使用。</p><p>注解本质是一个继承了<code>Annotation</code> 的特殊接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Override</span> <span class="keyword">extends</span> <span class="title class_">Annotation</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK 提供了很多内置的注解（比如 <code>@Override</code>、<code>@Deprecated</code>），同时，我们还可以自定义注解。</p><h2 id="内置的注解"><a href="#内置的注解" class="headerlink" title="内置的注解"></a>内置的注解</h2><p>Java 定义了一套注解，共有 7 个，3 个在 java.lang 中，剩下 4 个在 java.lang.annotation 中。</p><p><strong>作用在代码的注解是</strong></p><ul><li>@Override - 检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。</li><li>@Deprecated - 标记过时方法。如果使用该方法，会报编译警告。</li><li>@SuppressWarnings - 指示编译器去忽略注解中声明的警告。</li></ul><p>作用在其他注解的注解(或者说 元注解)是:</p><ul><li>@Retention - 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。</li><li>@Documented - 标记这些注解是否包含在用户文档中。</li><li>@Target - 标记这个注解应该是哪种 Java 成员。</li><li>@Inherited - 标记这个注解是继承于哪个注解类(默认 注解并没有继承于任何子类)</li></ul><p>从 Java 7 开始，额外添加了 3 个注解:</p><ul><li>@SafeVarargs - Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。</li><li>@FunctionalInterface - Java 8 开始支持，标识一个匿名函数或函数式接口。</li><li>@Repeatable - Java 8 开始支持，标识某注解可以在同一个声明上使用多次。</li></ul><hr><h2 id="注解的作用"><a href="#注解的作用" class="headerlink" title="注解的作用"></a>注解的作用</h2><p><code>Java</code>的注解可以分为三类：</p><p>第一类是由编译器使用的注解，例如：</p><ul><li><code>@Override</code>：让编译器检查该方法是否正确地实现了覆写；</li><li><code>@SuppressWarnings</code>：告诉编译器忽略此处代码产生的警告。</li></ul><p>这类注解不会被编译进入<code>.class</code>文件，它们在编译后就被编译器扔掉了。</p><p>第二类是由工具处理<code>.class</code>文件使用的注解，比如有些工具会在加载class的时候，对class做动态修改，实现一些特殊的功能。这类注解会被编译进入<code>.class</code>文件，但加载结束后并不会存在于内存中。这类注解只被一些底层库使用，一般我们不必自己处理。</p><p>第三类是在程序运行期能够读取的注解，它们在加载后一直存在于JVM中，这也是最常用的注解。例如，一个配置了<code>@PostConstruct</code>的方法会在调用构造方法后自动被调用（这是Java代码读取该注解实现的功能，JVM并不会识别该注解）。</p><hr><h2 id="注解的解析方法有哪几种？"><a href="#注解的解析方法有哪几种？" class="headerlink" title="注解的解析方法有哪几种？"></a>注解的解析方法有哪几种？</h2><p>注解只有被解析之后才会生效，常见的解析方法有两种：</p><ul><li><strong>编译期直接扫描</strong>：编译器在编译 Java 代码的时候扫描对应的注解并处理，比如某个方法使用<code>@Override</code> 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。</li><li><strong>运行期通过反射处理</strong>：像框架中自带的注解(比如 Spring 框架的 <code>@Value</code>、<code>@Component</code>)都是通过反射来进行处理的</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java核心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java核心-泛型</title>
      <link href="/posts/65682cd8/"/>
      <url>/posts/65682cd8/</url>
      
        <content type="html"><![CDATA[<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a><a href="#%E6%B3%9B%E5%9E%8B">泛型</a></h2><h3 id="什么是泛型？有什么作用？"><a href="#什么是泛型？有什么作用？" class="headerlink" title="什么是泛型？有什么作用？"></a><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B3%9B%E5%9E%8B-%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8">什么是泛型？有什么作用？</a></h3><p><strong>Java 泛型（Generics）</strong> 是 JDK 5 中引入的一个新特性。使用泛型参数，可以增强代码的可读性以及稳定性。</p><p>编译器可以对泛型参数进行检测，并且通过泛型参数可以指定传入的对象类型。比如 <code>ArrayList&lt;Person&gt; persons = new ArrayList&lt;Person&gt;()</code> 这行代码就指明了该 <code>ArrayList</code> 对象只能传入 <code>Person</code> 对象，如果传入其他类型的对象就会报错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br></pre></td></tr></table></figure><p>并且，原生 <code>List</code> 返回类型是 <code>Object</code> ，需要手动转换类型才能使用，使用泛型后编译器自动转换。</p><h3 id="泛型的使用方式有哪几种？"><a href="#泛型的使用方式有哪几种？" class="headerlink" title="泛型的使用方式有哪几种？"></a><a href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D">泛型的使用方式有哪几种？</a></h3><p>泛型一般有三种使用方式:<strong>泛型类</strong>、<strong>泛型接口</strong>、<strong>泛型方法</strong>。</p><hr><p><strong>1.泛型类</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span></span><br><span class="line"><span class="comment">//在实例化泛型类时，必须指定T的具体类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Generic</span>&lt;T&gt;&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Generic</span><span class="params">(T key)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getKey</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何实例化泛型类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Generic&lt;Integer&gt; genericInteger = <span class="keyword">new</span> <span class="title class_">Generic</span>&lt;Integer&gt;(<span class="number">123456</span>);</span><br></pre></td></tr></table></figure><p><strong>2.泛型接口</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Generator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现泛型接口，不指定类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GeneratorImpl</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Generator</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现泛型接口，指定类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GeneratorImpl</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Generator</span>&lt;String&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.泛型方法</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt; E &gt; <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">( E[] inputArray )</span></span><br><span class="line">&#123;</span><br><span class="line">      <span class="keyword">for</span> ( E element : inputArray )&#123;</span><br><span class="line">         System.out.printf( <span class="string">&quot;%s &quot;</span>, element );</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建不同类型数组：Integer, Double 和 Character</span></span><br><span class="line">Integer[] intArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">String[] stringArray = &#123; <span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span> &#125;;</span><br><span class="line">printArray( intArray  );</span><br><span class="line">printArray( stringArray  );</span><br></pre></td></tr></table></figure><blockquote><p>注意: <code>public static &lt; E &gt; void printArray( E[] inputArray )</code> 一般被称为静态泛型方法;在 java 中泛型只是一个占位符，必须在传递类型后才能使用。类在实例化时才能真正的传递类型参数，由于静态方法的加载先于类的实例化，也就是说类中的泛型还没有传递真正的类型参数，静态的方法的加载就已经完成了，所以静态泛型方法是没有办法使用类上声明的泛型的。只能使用自己声明的 <code>&lt;E&gt;</code></p></blockquote><h3 id="项目中哪里用到了泛型？"><a href="#项目中哪里用到了泛型？" class="headerlink" title="项目中哪里用到了泛型？"></a><a href="#%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%93%AA%E9%87%8C%E7%94%A8%E5%88%B0%E4%BA%86%E6%B3%9B%E5%9E%8B">项目中哪里用到了泛型？</a></h3><p>自定义接口通用返回结果 <code>CommonResult&lt;T&gt;</code> 通过参数 <code>T</code> 可根据具体的返回类型动态指定结果的数据类型</p><p>定义 <code>Excel</code> 处理类 <code>ExcelUtil&lt;T&gt;</code> 用于动态指定 <code>Excel</code> 导出的数据类型</p><p>构建集合工具类（参考 <code>Collections</code> 中的 <code>sort</code>, <code>binarySearch</code> 方法）</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java核心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java核心-反射</title>
      <link href="/posts/69e7170f/"/>
      <url>/posts/69e7170f/</url>
      
        <content type="html"><![CDATA[<h1 id="Java反射机制"><a href="#Java反射机制" class="headerlink" title="Java反射机制"></a>Java反射机制</h1><h2 id="反射机制是什么"><a href="#反射机制是什么" class="headerlink" title="反射机制是什么"></a>反射机制是什么</h2><blockquote><p>1、Java反射机制的核心是在程序运行时动态加载类并获取类的详细信息，从而操作类或对象的属性和方法。本质是JVM得到class对象之后，<strong>再通过class对象进行反编译，从而获取对象的各种信息。</strong><br>        2、Java属于先编译再运行的语言，程序中对象的类型在编译期就确定下来了，而当程序在运行时可能需要动态加载某些类，这些类因为之前用不到，所以没有被加载到JVM。通过反射，可以在运行时动态地创建对象并调用其属性，<strong>不需要提前在编译期知道运行的对象是谁。</strong></p><p>3、反射之所以被称为框架的灵魂，主要是因为它赋予了我们在运行时分析类以及执行类中方法的能力。通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性</p></blockquote><h2 id="反射的原理"><a href="#反射的原理" class="headerlink" title="反射的原理"></a>反射的原理</h2><p><a href="https://imgse.com/i/pkHAy1U"><img src="https://s21.ax1x.com/2024/07/23/pkHAy1U.jpg" alt="pkHAy1U.jpg"></a></p><h2 id="反射的应用场景"><a href="#反射的应用场景" class="headerlink" title="反射的应用场景"></a>反射的应用场景</h2><p>像咱们平时大部分时候都是在写业务代码，很少会接触到直接使用反射机制的场景。</p><p>但是，这并不代表反射没有用。相反，正是因为反射，你才能这么轻松地使用各种框架。像 Spring&#x2F;Spring Boot、MyBatis 等等框架中都大量使用了反射机制。</p><p>这些框架中也大量使用了<strong>动态代理</strong>，而动态代理的实现也<strong>依赖反射</strong>。</p><hr><p>例如我们经常使用的 Spring 配置中，经常会有相关 Bean 的配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.chenshuyi.Apple&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当我们在 XML 文件中配置了上面这段配置之后，<strong>Spring</strong> 便会在启动的时候<strong>利用反射去加载对应的 Apple 类</strong>。而当 Apple 类不存在或发生启发异常时，异常堆栈便会将异常指向调用的 invoke 方法。</p><p>从这里可以看出，我们平常很多框架都使用了反射，而反射中最最终的就是 Method 类的 invoke 方法了。</p><hr><p>Java 中的一大利器 <strong>注解</strong> 的实现也用到了反射。</p><h2 id="反射的优缺点"><a href="#反射的优缺点" class="headerlink" title="反射的优缺点"></a>反射的优缺点</h2><p>1、优点：</p><p>在运行时获得类的各种内容，进行反编译，对于Java这种先编译再运行的语言，能够让我们很方便的创建灵活的代码，这些代码可以在运行时装配，无需在组件之间进行源代码的链接，更加容易实现面向对象。</p><p>2、缺点：</p><p>（1）反射会消耗一定的系统资源，因此，如果不需要动态地创建一个对象，那么就不需要用反射；</p><p>（2）反射调用方法时可以忽略权限检查，因此可能会破坏封装性而导致安全问题。</p><h2 id="反射机制常用的类文件："><a href="#反射机制常用的类文件：" class="headerlink" title="反射机制常用的类文件："></a>反射机制常用的类文件：</h2><ul><li>Java.lang.Class;</li><li>Java.lang.reflect.Constructor;</li><li>Java.lang.reflect.Field;</li><li>Java.lang.reflect.Method;</li><li>Java.lang.reflect.Modifier;</li></ul><p>反射的作用</p><ul><li>动态创建对象</li><li>动态操作属性</li><li>动态调用方法</li></ul><p>在JDK中，主要由以下类来实现Java反射机制，<strong>这些类都位于java.lang.reflect包中</strong></p><ul><li>Class类：代表一个类</li><li>Constructor 类：代表类的构造方法</li><li>Field 类：代表类的成员变量(属性)</li><li>Method类：代表类的成员方法</li></ul><h2 id="反射的入口—Class类"><a href="#反射的入口—Class类" class="headerlink" title="反射的入口—Class类"></a>反射的入口—Class类</h2><p><strong>-Class类是Java 反射机制的起源和入口</strong></p><ul><li>用于获取与类相关的各种信息</li><li>提供了获取类信息的相关方法</li><li>Class类继承自Object类</li></ul><p><strong>-Class类是所有类的共同的图纸</strong></p><ul><li>每个类有自己的对象，好比图纸和实物的关系</li><li>每个类也可看做是一个对象，有共同的图纸Class，存放类的结构信息，比如类的名字、属性、方法、构造方法、父类和接口，能够通过相应方法取出相应信息</li></ul><p><strong>-Class类的对象称为类对象</strong></p><h1 id="反射实例"><a href="#反射实例" class="headerlink" title="反射实例"></a>反射实例</h1><p>获取一个类的类的对象的三种方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestClass2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span>  Exception &#123;</span><br><span class="line">        <span class="comment">//1.获取一个类的结构信息（类对象 Class对象）</span></span><br><span class="line">        <span class="comment">// 1.1Class.forName(类的完整路径字符串);</span></span><br><span class="line">        <span class="comment">//Class clazz = Class.forName(&quot;java.lang.String&quot;);</span></span><br><span class="line">        <span class="comment">//1.2 类名.class</span></span><br><span class="line">       <span class="comment">// Class clazz = String.class;</span></span><br><span class="line">        <span class="comment">//1.3 对象名.getClass()</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;bjsxt&quot;</span>;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> str.getClass();</span><br><span class="line">        <span class="comment">//Integer in = new Integer(20);</span></span><br><span class="line">        <span class="comment">//2.从类对象中获取类的各种结构信息</span></span><br><span class="line">        System.out.println(clazz.getName());</span><br><span class="line">        System.out.println(clazz.getSimpleName());</span><br><span class="line">        System.out.println(clazz.getSuperclass());</span><br><span class="line">        System.out.println(Arrays.toString(clazz.getInterfaces()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体可以看：<a href="https://zhuanlan.zhihu.com/p/405325823">https://zhuanlan.zhihu.com/p/405325823</a></p><p><a href="https://javaguide.cn/java/basis/reflection.html#%E5%8F%8D%E5%B0%84%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C">https://javaguide.cn/java/basis/reflection.html#%E5%8F%8D%E5%B0%84%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C</a></p><p><a href="https://blog.csdn.net/qq_44715943/article/details/120587716">https://blog.csdn.net/qq_44715943/article/details/120587716</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java核心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java时间戳</title>
      <link href="/posts/f00f6d65/"/>
      <url>/posts/f00f6d65/</url>
      
        <content type="html"><![CDATA[<h1 id="Java时间戳"><a href="#Java时间戳" class="headerlink" title="Java时间戳"></a>Java时间戳</h1><h2 id="一-何为Java时间戳"><a href="#一-何为Java时间戳" class="headerlink" title="一.何为Java时间戳"></a>一.何为Java时间戳</h2><p>在Java中，时间戳通常指的是自1970年1月1日午夜（<code>UTC</code>）以来的毫秒数。</p><p>这个概念在Java中主要通过<code>java.util.Date</code>类和<code>java.sql.Timestamp</code>类来表示</p><p>而在Java 8及以后的版本中，引入了新的日期时间<code>API</code>，即<code>java.time</code>包，提供了更多的功能和灵活性。</p><h2 id="二-获取当前时间戳"><a href="#二-获取当前时间戳" class="headerlink" title="二.获取当前时间戳"></a>二.获取当前时间戳</h2><h3 id="1-使用System-currentTimeMillis-方法"><a href="#1-使用System-currentTimeMillis-方法" class="headerlink" title="1.使用System.currentTimeMillis()方法"></a>1.使用<code>System.currentTimeMillis()</code>方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">currentTimestamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br></pre></td></tr></table></figure><h3 id="2-使用java-util-Date-类"><a href="#2-使用java-util-Date-类" class="headerlink" title="2. 使用java.util.Date 类"></a>2. 使用<code>java.util.Date</code> 类</h3><p><code>java.util.Date</code>类可以用来表示特定的瞬间，它包含了自1970年1月1日午夜（<code>UTC</code>）以来的毫秒数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个Date对象表示当前时间</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">now</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> now.getTime(); <span class="comment">// 获取时间戳</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从一个已知的时间戳创建Date对象</span></span><br><span class="line"><span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> ... <span class="comment">// 假设你有一个时间戳</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(timestamp);</span><br></pre></td></tr></table></figure><h3 id="3-使用java-sql-Timestamp-类"><a href="#3-使用java-sql-Timestamp-类" class="headerlink" title="3. 使用java.sql.Timestamp 类"></a>3. 使用<code>java.sql.Timestamp</code> 类</h3><p><code>java.sql.Timestamp</code>类是<code>java.util.Date</code>的一个子类，它提供了更高精度的时间表示，包括纳秒</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个Timestamp对象表示当前时间</span></span><br><span class="line"><span class="type">Timestamp</span> <span class="variable">now</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timestamp</span>(System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从一个已知的时间戳创建Timestamp对象</span></span><br><span class="line"><span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> ... <span class="comment">// 假设你有一个时间戳</span></span><br><span class="line"><span class="type">Timestamp</span> <span class="variable">ts</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timestamp</span>(timestamp);</span><br></pre></td></tr></table></figure><h3 id="4-Java-8中的-java-time-包"><a href="#4-Java-8中的-java-time-包" class="headerlink" title="4.Java 8中的 java.time 包"></a>4.<code>Java </code>8中的 <code>java.time</code> 包</h3><p>Java 8引入了一个新的日期时间API，提供了更好的处理日期和时间的类。其中，<code>Instant</code>类可以用来表示时间戳。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前时间的Instant对象</span></span><br><span class="line"><span class="type">Instant</span> <span class="variable">now</span> <span class="operator">=</span> Instant.now();</span><br><span class="line"><span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> now.toEpochMilli(); <span class="comment">// 获取时间戳</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从一个已知的时间戳创建Instant对象</span></span><br><span class="line"><span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> ... <span class="comment">// 假设你有一个时间戳</span></span><br><span class="line"><span class="type">Instant</span> <span class="variable">instant</span> <span class="operator">=</span> Instant.ofEpochMilli(timestamp);</span><br></pre></td></tr></table></figure><h2 id="三-格式化时间戳"><a href="#三-格式化时间戳" class="headerlink" title="三.格式化时间戳"></a>三.格式化时间戳</h2><p>要将时间戳转换为可读的日期时间格式，可以使用<code>SimpleDateFormat</code>（Java 8之前）或<code>DateTimeFormatter</code>（Java 8及以后）。</p><h3 id="1-使用-SimpleDateFormat"><a href="#1-使用-SimpleDateFormat" class="headerlink" title="1.使用 SimpleDateFormat"></a>1.使用 <code>SimpleDateFormat</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设你有一个时间戳</span></span><br><span class="line"><span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建SimpleDateFormat对象</span></span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将时间戳转换为Date对象，然后格式化</span></span><br><span class="line"><span class="type">String</span> <span class="variable">formattedDate</span> <span class="operator">=</span> sdf.format(<span class="keyword">new</span> <span class="title class_">Date</span>(timestamp));</span><br><span class="line">System.out.println(formattedDate);</span><br></pre></td></tr></table></figure><h3 id="2-使用-DateTimeFormatter"><a href="#2-使用-DateTimeFormatter" class="headerlink" title="2.使用 DateTimeFormatter"></a>2.使用 <code>DateTimeFormatter</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设你有一个时间戳</span></span><br><span class="line"><span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建DateTimeFormatter对象</span></span><br><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">dtf</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将时间戳转换为Instant对象，然后转换为LocalDateTime对象，最后格式化</span></span><br><span class="line"><span class="type">Instant</span> <span class="variable">instant</span> <span class="operator">=</span> Instant.ofEpochMilli(timestamp);</span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">ldt</span> <span class="operator">=</span> LocalDateTime.ofInstant(instant, ZoneId.systemDefault());</span><br><span class="line"><span class="type">String</span> <span class="variable">formattedDate</span> <span class="operator">=</span> ldt.format(dtf);</span><br><span class="line">System.out.println(formattedDate);</span><br></pre></td></tr></table></figure><h2 id="四-时间戳与字符串的转换"><a href="#四-时间戳与字符串的转换" class="headerlink" title="四.时间戳与字符串的转换"></a>四.时间戳与字符串的转换</h2><h3 id="1-将时间戳转换为字符串"><a href="#1-将时间戳转换为字符串" class="headerlink" title="1.将时间戳转换为字符串"></a>1.将时间戳转换为字符串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设你有一个时间戳</span></span><br><span class="line"><span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用SimpleDateFormat</span></span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">dateStr</span> <span class="operator">=</span> sdf.format(<span class="keyword">new</span> <span class="title class_">Date</span>(timestamp));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用DateTimeFormatter</span></span><br><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">dtf</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"><span class="type">Instant</span> <span class="variable">instant</span> <span class="operator">=</span> Instant.ofEpochMilli(timestamp);</span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">ldt</span> <span class="operator">=</span> LocalDateTime.ofInstant(instant, ZoneId.systemDefault());</span><br><span class="line"><span class="type">String</span> <span class="variable">dateStr</span> <span class="operator">=</span> ldt.format(dtf);</span><br></pre></td></tr></table></figure><h3 id="2-将字符串转换为时间戳"><a href="#2-将字符串转换为时间戳" class="headerlink" title="2.将字符串转换为时间戳"></a>2.将字符串转换为时间戳</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设你有一个日期时间的字符串表示</span></span><br><span class="line"><span class="type">String</span> <span class="variable">dateStr</span> <span class="operator">=</span> <span class="string">&quot;2023-04-01 12:34:56&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用SimpleDateFormat</span></span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> sdf.parse(dateStr);</span><br><span class="line">    <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> date.getTime();</span><br><span class="line">&#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用DateTimeFormatter</span></span><br><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">dtf</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">ldt</span> <span class="operator">=</span> LocalDateTime.parse(dateStr, dtf);</span><br><span class="line"><span class="type">Instant</span> <span class="variable">instant</span> <span class="operator">=</span> ldt.atZone(ZoneId.systemDefault()).toInstant();</span><br><span class="line"><span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> instant.toEpochMilli();</span><br></pre></td></tr></table></figure><h2 id="五-时区处理"><a href="#五-时区处理" class="headerlink" title="五.时区处理"></a>五.时区处理</h2><p>在处理时间戳时，时区是一个非常重要的因素。Java中的<code>ZoneId</code>类可以用来表示不同的时区。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前时区的偏移量</span></span><br><span class="line"><span class="type">ZoneId</span> <span class="variable">currentZone</span> <span class="operator">=</span> ZoneId.systemDefault();</span><br><span class="line"><span class="type">ZonedDateTime</span> <span class="variable">zdt</span> <span class="operator">=</span> ZonedDateTime.now(currentZone);</span><br><span class="line"><span class="type">long</span> <span class="variable">offsetInMillis</span> <span class="operator">=</span> zdt.getOffset().getTotalSeconds() * <span class="number">1000</span>;</span><br></pre></td></tr></table></figure><h2 id="六-时间戳的加减"><a href="#六-时间戳的加减" class="headerlink" title="六.时间戳的加减"></a>六.时间戳的加减</h2><p>要对时间戳进行加减操作，可以使用<code>java.time.Duration</code>类或直接对毫秒数进行加减。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设你有一个时间戳</span></span><br><span class="line"><span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加一小时的时间戳</span></span><br><span class="line"><span class="type">Instant</span> <span class="variable">instant</span> <span class="operator">=</span> Instant.ofEpochMilli(timestamp);</span><br><span class="line"><span class="type">Duration</span> <span class="variable">oneHour</span> <span class="operator">=</span> Duration.ofHours(<span class="number">1</span>);</span><br><span class="line"><span class="type">Instant</span> <span class="variable">newInstant</span> <span class="operator">=</span> instant.plus(oneHour);</span><br><span class="line"><span class="type">long</span> <span class="variable">newTimestamp</span> <span class="operator">=</span> newInstant.toEpochMilli();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者直接对毫秒数进行加减</span></span><br><span class="line"><span class="type">long</span> <span class="variable">newTimestamp</span> <span class="operator">=</span> timestamp + (<span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>); <span class="comment">// 增加一小时</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>变量与数据类型</title>
      <link href="/posts/f5b2a257/"/>
      <url>/posts/f5b2a257/</url>
      
        <content type="html"><![CDATA[<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p><strong>定义：变量是存储数据值的容器。</strong></p><p>所有 Java 变量必须用唯一的名称标识，这些唯一的名称称为<strong>标识符</strong>。</p><p>变量名称（唯一标识符）的一般命名规则如下：</p><ul><li>名称可以包含字母、数字、下划线和$符号</li><li>姓名必须以字母开头</li><li>名称应以小写字母开头，并且不能包含空格</li><li>名称也可以以$和_开头（但在本教程中我们将不使用它）</li><li>名称区分大小写 (“myVar” 和 “myvar” 是不同的变量)</li><li>保留字（如 Java关键字：int、boolean）不能用作名称</li></ul><h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">myNum</span> <span class="operator">=</span> <span class="number">5</span>;               <span class="comment">// 整数（整数）</span></span><br><span class="line"><span class="type">float</span> <span class="variable">myFloatNum</span> <span class="operator">=</span> <span class="number">5.99f</span>;    <span class="comment">// 浮点数</span></span><br><span class="line"><span class="type">char</span> <span class="variable">myLetter</span> <span class="operator">=</span> <span class="string">&#x27;D&#x27;</span>;         <span class="comment">// 字符</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">myBool</span> <span class="operator">=</span> <span class="literal">true</span>;       <span class="comment">// Boolean</span></span><br><span class="line"><span class="type">String</span> <span class="variable">myText</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;     <span class="comment">// 字符串</span></span><br></pre></td></tr></table></figure><p>一个字节是1byte，1024字节是1K，1024K是M，1024M是1G，1024G是1T</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">       ┌───┐</span><br><span class="line">  byte │   │</span><br><span class="line">       └───┘</span><br><span class="line">       ┌───┬───┐</span><br><span class="line"> short │   │   │</span><br><span class="line">       └───┴───┘</span><br><span class="line">       ┌───┬───┬───┬───┐</span><br><span class="line">   int │   │   │   │   │</span><br><span class="line">       └───┴───┴───┴───┘</span><br><span class="line">       ┌───┬───┬───┬───┬───┬───┬───┬───┐</span><br><span class="line">  long │   │   │   │   │   │   │   │   │</span><br><span class="line">       └───┴───┴───┴───┴───┴───┴───┴───┘</span><br><span class="line">       ┌───┬───┬───┬───┐</span><br><span class="line"> float │   │   │   │   │</span><br><span class="line">       └───┴───┴───┴───┘</span><br><span class="line">       ┌───┬───┬───┬───┬───┬───┬───┬───┐</span><br><span class="line">double │   │   │   │   │   │   │   │   │</span><br><span class="line">       └───┴───┴───┴───┴───┴───┴───┴───┘</span><br><span class="line">       ┌───┬───┐</span><br><span class="line">  char │   │   │</span><br><span class="line">       └───┴───┘</span><br></pre></td></tr></table></figure><h1 id="java数据类型转换"><a href="#java数据类型转换" class="headerlink" title="java数据类型转换"></a>java数据类型转换</h1><p>数据类型转换是把数据从一种类型转换为另一种类型。</p><p>在Java中，有两种类型的数据转换：</p><ul><li><p><strong>隐式类型转换</strong> (自动) - 从小类型到大类型，不需要强制转换符<br><code>byte</code> 、 <code>short</code> 、 <code>char</code> -&gt; <code>int</code> -&gt; <code>long</code> -&gt; <code>float</code> -&gt; <code>double</code></p><p><a href="https://imgse.com/i/pkHCkHP"><img src="https://s21.ax1x.com/2024/07/23/pkHCkHP.png" alt="pkHCkHP.png"></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将较小的类型转换为较大的类型时使用，不需要强制转换符</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">myInt</span> <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line">    <span class="type">double</span> <span class="variable">myDouble</span> <span class="operator">=</span> myInt; <span class="comment">// 自动转换: int 到 double</span></span><br><span class="line"></span><br><span class="line">    System.out.println(myInt);      <span class="comment">// 输出 9</span></span><br><span class="line">    System.out.println(myDouble);   <span class="comment">// 输出 9.0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>强制类型转换</strong> (手动) - 从大类型到小类型，需要强制转换符实现强制转换<br><code>double</code> -&gt; <code>float</code> -&gt; <code>long</code> -&gt; <code>int</code> -&gt; <code>char</code> -&gt; <code>short</code> -&gt; <code>byte</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将较大的类型转换为较小的类型时使用，需要强制转换符实现强制转换</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">myDouble</span> <span class="operator">=</span> <span class="number">9.78</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">myInt</span> <span class="operator">=</span> (<span class="type">int</span>) myDouble; <span class="comment">// 手动转换：double 到 int</span></span><br><span class="line"></span><br><span class="line">    System.out.println(myDouble);   <span class="comment">// 输出 9.78</span></span><br><span class="line">    System.out.println(myInt);      <span class="comment">// 输出 9</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">    <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span>  (<span class="type">byte</span>)a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><p>Java 将运算符划分为下列类型：</p><ul><li><p>算术运算符</p><table><thead><tr><th>运算符</th><th>名称</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>+</td><td>加法</td><td>将两个值相加</td><td>x + y</td></tr><tr><td>-</td><td>减法</td><td>从一个值减去另一个值</td><td>x - y</td></tr><tr><td>*</td><td>乘法</td><td>将两个值相乘</td><td>x * y</td></tr><tr><td>&#x2F;</td><td>除法</td><td>分子除以分母</td><td>x &#x2F; y</td></tr><tr><td>%</td><td>取模</td><td>取模运算符，整除后的余数</td><td>x % y</td></tr><tr><td>++</td><td>自增</td><td>自增运算符，整数值增加 1</td><td>++x</td></tr><tr><td>–</td><td>自减</td><td>自减运算符，整数值减少 1</td><td>–x</td></tr></tbody></table><p><strong><code>++n</code>表示先加1再引用n，<code>n++</code>表示先引用n再加1</strong></p></li><li><p>赋值运算符</p><table><thead><tr><th>运算符</th><th>实例</th><th>等同于</th><th>解释</th></tr></thead><tbody><tr><td>&#x3D;</td><td>x &#x3D; 5</td><td>x &#x3D; 5</td><td>赋值</td></tr><tr><td>+&#x3D;</td><td>x +&#x3D; 3</td><td>x &#x3D; x + 3</td><td>加</td></tr><tr><td>-&#x3D;</td><td>x -&#x3D; 3</td><td>x &#x3D; x - 3</td><td>减</td></tr><tr><td>*&#x3D;</td><td>x *&#x3D; 3</td><td>x &#x3D; x * 3</td><td>乘</td></tr><tr><td>&#x2F;&#x3D;</td><td>x &#x2F;&#x3D; 3</td><td>x &#x3D; x &#x2F; 3</td><td>除</td></tr><tr><td>%&#x3D;</td><td>x %&#x3D; 3</td><td>x &#x3D; x % 3</td><td>取余</td></tr><tr><td>&amp;&#x3D;</td><td>x &amp;&#x3D; 3</td><td>x &#x3D; x &amp; 3</td><td>按位与运算<br>将两个数的二进制表示进行逐位比较<br>如果相应位上的两个数都为1，<br>则结果为1，否则为0。</td></tr><tr><td>|&#x3D;</td><td>x |&#x3D; 3</td><td>x &#x3D; x | 3</td><td>按位或运算<br>将两个数的二进制表示进行逐位比较<br>如果相应位上的两个数中至少有一个为1，<br>则结果为1，否则为0。</td></tr><tr><td>^&#x3D;</td><td>x ^&#x3D; 3</td><td>x &#x3D; x ^ 3</td><td>按位异或运算<br>将两个数的二进制表示进行逐位比较<br>如果相应位上的两个数不相同，则结果为1，否则为0。</td></tr><tr><td>&gt;&gt;&#x3D;</td><td>x &gt;&gt;&#x3D; 3</td><td>x &#x3D; x &gt;&gt; 3</td><td>表示将变量x的二进制表示向右移动3位<br>将一个数的二进制表示向右移动指定的位数<br>移出的位将被丢弃，右边空出的位用0填充。</td></tr><tr><td>&lt;&lt;&#x3D;</td><td>x &lt;&lt;&#x3D; 3</td><td>x &#x3D; x &lt;&lt; 3</td><td>表示将变量x的二进制表示向左移动3位<br>将一个数的二进制表示向左移动指定的位数<br>左边空出的位用0填充，右边移出的位将被丢弃。</td></tr></tbody></table></li><li><p>关系运算符</p><table><thead><tr><th>运算符</th><th>名称</th><th>实例</th></tr></thead><tbody><tr><td>&#x3D;&#x3D;</td><td>等于</td><td>x &#x3D;&#x3D; y</td></tr><tr><td>!&#x3D;</td><td>不等于</td><td>x !&#x3D; y</td></tr><tr><td>&gt;</td><td>大于</td><td>x &gt; y</td></tr><tr><td>&lt;</td><td>小于</td><td>x &lt; y</td></tr><tr><td>&gt;&#x3D;</td><td>大于或等于</td><td>x &gt;&#x3D; y</td></tr><tr><td>&lt;&#x3D;</td><td>小于或等于</td><td>x &lt;&#x3D; y</td></tr></tbody></table></li><li><p>逻辑运算符</p><table><thead><tr><th>运算符</th><th>名称</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>&amp;&amp;</td><td>逻辑与</td><td>如果两个语句都为true，则返回true</td><td>x &lt; 5 &amp;&amp; x &lt; 10</td></tr><tr><td>||</td><td>逻辑或</td><td>如果其中一条语句为true，则返回true</td><td>x &lt; 5 || x &lt; 4</td></tr><tr><td>!</td><td>逻辑非</td><td>反转结果，如果结果为真则返回false</td><td>!(x &lt; 5 &amp;&amp; x &lt; 10)</td></tr></tbody></table></li><li><p>位运算符</p><table><thead><tr><th>运算符</th><th>描述</th><th>例子</th><th>等同于</th><th>结果</th><th>十进制</th></tr></thead><tbody><tr><td>&amp;</td><td>AND - 如果两个位都为 1，则将每个位设置为 1</td><td>5 &amp; 1</td><td>0101 &amp; 0001</td><td>0001</td><td>1</td></tr><tr><td>|</td><td>OR - 如果两个位中的任何一个为 1，则将每个位设置为 1</td><td>5 | 1</td><td>0101 | 0001</td><td>0101</td><td>5</td></tr><tr><td>~</td><td>NOT - 反转所有位</td><td>~ 5</td><td>~0101</td><td>1010</td><td>10</td></tr><tr><td>^</td><td>XOR - 如果两个位中只有一个为 1，则将每个位设置为 1</td><td>5 ^ 1</td><td>0101 ^ 0001</td><td>0100</td><td>4</td></tr><tr><td>&lt;&lt;</td><td>Zero-fill left shift - 通过从右侧推入零并让最左边的位脱落来向左移动</td><td>9 &lt;&lt; 1</td><td>1001 &lt;&lt; 1</td><td>0010</td><td>2</td></tr><tr><td>&gt;&gt;</td><td>Signed right shift - 通过从左侧推入最左侧位的副本并让最右侧位脱落来右移</td><td>9 &gt;&gt; 1</td><td>1001 &gt;&gt; 1</td><td>1100</td><td>12</td></tr><tr><td>&gt;&gt;&gt;</td><td>Zero-fill right shift - 通过从左边推入零并让最右边的位脱落来右移</td><td>9 &gt;&gt;&gt; 1</td><td>1001 &gt;&gt;&gt; 1</td><td>0100</td><td>4</td></tr></tbody></table></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础-study01</title>
      <link href="/posts/7f1ae6d2/"/>
      <url>/posts/7f1ae6d2/</url>
      
        <content type="html"><![CDATA[<h1 id="Java简介"><a href="#Java简介" class="headerlink" title="Java简介"></a>Java简介</h1><p><em><strong>Java是面向对象的语言</strong></em></p><h2 id="Java的三个版本"><a href="#Java的三个版本" class="headerlink" title="Java的三个版本"></a>Java的三个版本</h2><ul><li>Java SE：Standard Edition</li><li>Java EE：Enterprise Edition</li><li>Java ME：Micro Edition</li></ul><p><a href="https://imgse.com/i/pkHCCjA"><img src="https://s21.ax1x.com/2024/07/23/pkHCCjA.png" alt="pkHCCjA.png"></a></p><p>简单来说，Java SE就是标准版，包含标准的JVM和标准库，而Java EE是企业版，它只是在Java SE的基础上加上了大量的API和库，以便方便开发Web应用、数据库、消息服务等，Java EE的应用使用的虚拟机和Java SE完全相同。</p><p>Java ME就和Java SE不同，它是一个针对嵌入式设备的“瘦身版”，Java SE的标准库无法在Java ME上使用，Java ME的虚拟机也是“瘦身版”。</p><h1 id="Java程序基础"><a href="#Java程序基础" class="headerlink" title="Java程序基础"></a>Java程序基础</h1><h2 id="一-Java程序基本结构"><a href="#一-Java程序基本结构" class="headerlink" title="一.Java程序基本结构"></a>一.Java程序基本结构</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可以用来自动创建文档的注释</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 向屏幕输出文本:</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">        <span class="comment">/* 多行注释开始</span></span><br><span class="line"><span class="comment">        注释内容</span></span><br><span class="line"><span class="comment">        注释结束 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// class定义结束</span></span><br></pre></td></tr></table></figure><p><a href="https://imgse.com/i/pkHC9cd"><img src="https://s21.ax1x.com/2024/07/23/pkHC9cd.jpg" alt="pkHC9cd.jpg"></a></p><p>一个程序的基本单位就是<code>class</code>，<code>class</code>是<a href="Java%E5%85%B3%E9%94%AE%E5%AD%97.md">关键字</a>，这里定义的<code>class</code>名字就是<code>Hello</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123; <span class="comment">// 类名是Hello</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="comment">// class定义结束</span></span><br></pre></td></tr></table></figure><p>类名要求：</p><p>推荐–&gt;[驼峰命名规则]：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">printEmployeePaychecks();<span class="comment">//骆驼式命名</span></span><br><span class="line">print_employee_paychecks();<span class="comment">//下划线法命名</span></span><br></pre></td></tr></table></figure><ul><li>类名必须以英文字母开头，后接字母，数字和下划线的组合</li><li>习惯以大写字母开头</li></ul><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>注释可用于解释Java代码，并使其更具可读性。还可用于在测试替代代码时防止执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单行注释</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">多行注释</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可以用来自动创建文档的注释</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@auther</span> liaoxuefeng</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
